// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FINAL_USER_TEST_PROTO_H_
#define FLATBUFFERS_GENERATED_FINAL_USER_TEST_PROTO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace uSer {
namespace test {
namespace proto {

struct Person;
struct PersonBuilder;

struct Person FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PersonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_C = 8,
    VT_D = 10,
    VT_E = 12,
    VT_F = 14,
    VT_G = 16,
    VT_H = 18,
    VT_I = 20,
    VT_J = 22,
    VT_K = 24
  };
  const ::flatbuffers::String *A() const {
    return GetPointer<const ::flatbuffers::String *>(VT_A);
  }
  const ::flatbuffers::String *B() const {
    return GetPointer<const ::flatbuffers::String *>(VT_B);
  }
  const ::flatbuffers::String *C() const {
    return GetPointer<const ::flatbuffers::String *>(VT_C);
  }
  const ::flatbuffers::String *D() const {
    return GetPointer<const ::flatbuffers::String *>(VT_D);
  }
  const ::flatbuffers::String *E() const {
    return GetPointer<const ::flatbuffers::String *>(VT_E);
  }
  const ::flatbuffers::String *F() const {
    return GetPointer<const ::flatbuffers::String *>(VT_F);
  }
  const ::flatbuffers::String *G() const {
    return GetPointer<const ::flatbuffers::String *>(VT_G);
  }
  const ::flatbuffers::String *H() const {
    return GetPointer<const ::flatbuffers::String *>(VT_H);
  }
  const ::flatbuffers::String *I() const {
    return GetPointer<const ::flatbuffers::String *>(VT_I);
  }
  const ::flatbuffers::String *J() const {
    return GetPointer<const ::flatbuffers::String *>(VT_J);
  }
  const ::flatbuffers::String *K() const {
    return GetPointer<const ::flatbuffers::String *>(VT_K);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_A) &&
           verifier.VerifyString(A()) &&
           VerifyOffset(verifier, VT_B) &&
           verifier.VerifyString(B()) &&
           VerifyOffset(verifier, VT_C) &&
           verifier.VerifyString(C()) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyString(D()) &&
           VerifyOffset(verifier, VT_E) &&
           verifier.VerifyString(E()) &&
           VerifyOffset(verifier, VT_F) &&
           verifier.VerifyString(F()) &&
           VerifyOffset(verifier, VT_G) &&
           verifier.VerifyString(G()) &&
           VerifyOffset(verifier, VT_H) &&
           verifier.VerifyString(H()) &&
           VerifyOffset(verifier, VT_I) &&
           verifier.VerifyString(I()) &&
           VerifyOffset(verifier, VT_J) &&
           verifier.VerifyString(J()) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.VerifyString(K()) &&
           verifier.EndTable();
  }
};

struct PersonBuilder {
  typedef Person Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_A(::flatbuffers::Offset<::flatbuffers::String> A) {
    fbb_.AddOffset(Person::VT_A, A);
  }
  void add_B(::flatbuffers::Offset<::flatbuffers::String> B) {
    fbb_.AddOffset(Person::VT_B, B);
  }
  void add_C(::flatbuffers::Offset<::flatbuffers::String> C) {
    fbb_.AddOffset(Person::VT_C, C);
  }
  void add_D(::flatbuffers::Offset<::flatbuffers::String> D) {
    fbb_.AddOffset(Person::VT_D, D);
  }
  void add_E(::flatbuffers::Offset<::flatbuffers::String> E) {
    fbb_.AddOffset(Person::VT_E, E);
  }
  void add_F(::flatbuffers::Offset<::flatbuffers::String> F) {
    fbb_.AddOffset(Person::VT_F, F);
  }
  void add_G(::flatbuffers::Offset<::flatbuffers::String> G) {
    fbb_.AddOffset(Person::VT_G, G);
  }
  void add_H(::flatbuffers::Offset<::flatbuffers::String> H) {
    fbb_.AddOffset(Person::VT_H, H);
  }
  void add_I(::flatbuffers::Offset<::flatbuffers::String> I) {
    fbb_.AddOffset(Person::VT_I, I);
  }
  void add_J(::flatbuffers::Offset<::flatbuffers::String> J) {
    fbb_.AddOffset(Person::VT_J, J);
  }
  void add_K(::flatbuffers::Offset<::flatbuffers::String> K) {
    fbb_.AddOffset(Person::VT_K, K);
  }
  explicit PersonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Person> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Person>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Person> CreatePerson(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> A = 0,
    ::flatbuffers::Offset<::flatbuffers::String> B = 0,
    ::flatbuffers::Offset<::flatbuffers::String> C = 0,
    ::flatbuffers::Offset<::flatbuffers::String> D = 0,
    ::flatbuffers::Offset<::flatbuffers::String> E = 0,
    ::flatbuffers::Offset<::flatbuffers::String> F = 0,
    ::flatbuffers::Offset<::flatbuffers::String> G = 0,
    ::flatbuffers::Offset<::flatbuffers::String> H = 0,
    ::flatbuffers::Offset<::flatbuffers::String> I = 0,
    ::flatbuffers::Offset<::flatbuffers::String> J = 0,
    ::flatbuffers::Offset<::flatbuffers::String> K = 0) {
  PersonBuilder builder_(_fbb);
  builder_.add_K(K);
  builder_.add_J(J);
  builder_.add_I(I);
  builder_.add_H(H);
  builder_.add_G(G);
  builder_.add_F(F);
  builder_.add_E(E);
  builder_.add_D(D);
  builder_.add_C(C);
  builder_.add_B(B);
  builder_.add_A(A);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Person> CreatePersonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *A = nullptr,
    const char *B = nullptr,
    const char *C = nullptr,
    const char *D = nullptr,
    const char *E = nullptr,
    const char *F = nullptr,
    const char *G = nullptr,
    const char *H = nullptr,
    const char *I = nullptr,
    const char *J = nullptr,
    const char *K = nullptr) {
  auto A__ = A ? _fbb.CreateString(A) : 0;
  auto B__ = B ? _fbb.CreateString(B) : 0;
  auto C__ = C ? _fbb.CreateString(C) : 0;
  auto D__ = D ? _fbb.CreateString(D) : 0;
  auto E__ = E ? _fbb.CreateString(E) : 0;
  auto F__ = F ? _fbb.CreateString(F) : 0;
  auto G__ = G ? _fbb.CreateString(G) : 0;
  auto H__ = H ? _fbb.CreateString(H) : 0;
  auto I__ = I ? _fbb.CreateString(I) : 0;
  auto J__ = J ? _fbb.CreateString(J) : 0;
  auto K__ = K ? _fbb.CreateString(K) : 0;
  return uSer::test::proto::CreatePerson(
      _fbb,
      A__,
      B__,
      C__,
      D__,
      E__,
      F__,
      G__,
      H__,
      I__,
      J__,
      K__);
}

inline const uSer::test::proto::Person *GetPerson(const void *buf) {
  return ::flatbuffers::GetRoot<uSer::test::proto::Person>(buf);
}

inline const uSer::test::proto::Person *GetSizePrefixedPerson(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<uSer::test::proto::Person>(buf);
}

inline bool VerifyPersonBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<uSer::test::proto::Person>(nullptr);
}

inline bool VerifySizePrefixedPersonBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<uSer::test::proto::Person>(nullptr);
}

inline void FinishPersonBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<uSer::test::proto::Person> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPersonBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<uSer::test::proto::Person> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace proto
}  // namespace test
}  // namespace uSer

#endif  // FLATBUFFERS_GENERATED_FINAL_USER_TEST_PROTO_H_
